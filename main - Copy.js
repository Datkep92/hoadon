// ======================= DANH S√ÅCH C·ªòT EXCEL =======================
const ALL_COLS = [
  "Hi·ªÉn th·ªã tr√™n s·ªï","H√¨nh th·ª©c b√°n h√†ng","Ph∆∞∆°ng th·ª©c thanh to√°n","Ki√™m phi·∫øu xu·∫•t kho",
  "XK v√†o khu phi thu·∫ø quan v√† c√°c TH ƒë∆∞·ª£c coi nh∆∞ XK","L·∫≠p k√®m h√≥a ƒë∆°n","ƒê√£ l·∫≠p h√≥a ƒë∆°n",
  "Ng√†y h·∫°ch to√°n (*)","Ng√†y ch·ª©ng t·ª´ (*)","S·ªë ch·ª©ng t·ª´ (*)","S·ªë phi·∫øu xu·∫•t","L√Ω do xu·∫•t",
  "S·ªë h√≥a ƒë∆°n","Ng√†y h√≥a ƒë∆°n","M√£ kh√°ch h√†ng","T√™n kh√°ch h√†ng","ƒê·ªãa ch·ªâ","M√£ s·ªë thu·∫ø","Di·ªÖn gi·∫£i",
  "N·ªôp v√†o TK","NV b√°n h√†ng","M√£ h√†ng (*)","T√™n h√†ng","H√†ng khuy·∫øn m·∫°i","TK Ti·ªÅn/Chi ph√≠/N·ª£ (*)",
  "TK Doanh thu/C√≥ (*)","ƒêVT","S·ªë l∆∞·ª£ng","ƒê∆°n gi√° sau thu·∫ø","ƒê∆°n gi√°","Th√†nh ti·ªÅn","T·ª∑ l·ªá CK (%)",
  "Ti·ªÅn chi·∫øt kh·∫•u","TK chi·∫øt kh·∫•u","Gi√° t√≠nh thu·∫ø XK","% thu·∫ø XK","Ti·ªÅn thu·∫ø XK","TK thu·∫ø XK",
  "% thu·∫ø GTGT","T·ª∑ l·ªá t√≠nh thu·∫ø (Thu·∫ø su·∫•t KHAC)","Ti·ªÅn thu·∫ø GTGT","TK thu·∫ø GTGT",
  "HH kh√¥ng TH tr√™n t·ªù khai thu·∫ø GTGT","Kho","TK gi√° v·ªën","TK Kho","ƒê∆°n gi√° v·ªën","Ti·ªÅn v·ªën",
  "H√†ng h√≥a gi·ªØ h·ªô/b√°n h·ªô"
];

// ======================= BI·∫æN L∆ØU =======================
const xmlRows = [];
const seenInvoiceKeys = new Set();

// ======================= FLATTEN XML =======================
function flattenXml(xmlText) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(xmlText, "text/xml");
  const map = {};
  function walk(node, path) {
    const children = Array.from(node.children || []);
    if (children.length === 0) {
      const text = (node.textContent || "").trim();
      if (text) map[path] = text;
      return;
    }
    const counter = {};
    for (const child of children) {
      const name = child.nodeName;
      counter[name] = (counter[name] || 0) + 1;
      const idx = counter[name];
      const hasMany = children.filter(n => n.nodeName === name).length > 1;
      const childPath = `${path}.${name}${hasMany ? `[${idx}]` : ""}`;
      walk(child, childPath);
    }
  }
  walk(doc.documentElement, doc.documentElement.nodeName);
  return map;
}

// ======================= MAP C·ªòT ‚Üî XML =======================
const XML_MAPPING = {
  "Ng√†y h·∫°ch to√°n (*)": "HDon.DLHDon.TTChung.NLap",
  "Ng√†y ch·ª©ng t·ª´ (*)": "HDon.DLHDon.TTChung.NLap",
  "Ng√†y h√≥a ƒë∆°n": "HDon.DLHDon.TTChung.NLap",
  "S·ªë ch·ª©ng t·ª´ (*)": "HDon.DLHDon.TTChung.SHDon",
  "S·ªë phi·∫øu xu·∫•t": "HDon.DLHDon.TTChung.SHDon",
  "S·ªë h√≥a ƒë∆°n": "HDon.DLHDon.TTChung.SHDon",
  "T√™n kh√°ch h√†ng": "HDon.DLHDon.NDHDon.NMua.Ten",
  "M√£ s·ªë thu·∫ø": "HDon.DLHDon.NDHDon.NMua.MST",
  "ƒê·ªãa ch·ªâ": "HDon.DLHDon.NDHDon.NMua.DChi",
  "M√£ h√†ng (*)": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.MHHDVu",
  "T√™n h√†ng": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.THHDVu",
  "ƒêVT": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.DVTinh",
  "S·ªë l∆∞·ª£ng": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.SLuong",
  "ƒê∆°n gi√°": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.DGia",
  "Th√†nh ti·ªÅn": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.ThTien",
  "% thu·∫ø GTGT": "HDon.DLHDon.NDHDon.DSHHDVu.HHDVu.TSuat",
  "Ti·ªÅn thu·∫ø GTGT": "HDon.DLHDon.NDHDon.TToan.THTTLTSuat.LTSuat.TThue"
};

// ======================= T·∫†O ROW =======================
// ======================= X·ª¨ L√ù CHU·ªñI =======================
function stripVN(s = "") {
  return s
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/ƒë/g, "d").replace(/ƒê/g, "D");
}

function removeVietnameseAccents(str) {
  return str.normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .replace(/ƒë/g, "d")
    .replace(/ƒê/g, "D");
}



// ======================= SINH M√É SP =======================
function removeVietnameseAccents(str) {
  return str.normalize("NFD").replace(/\p{Diacritic}/gu, "")
    .replace(/ƒë/g, "d").replace(/ƒê/g, "D");
}

function generateProductCodeByName(productName) {
  if (!productName) return "";

  let clean = removeVietnameseAccents(productName.toUpperCase().trim());

  // 1. L·∫•y k√Ω t·ª± ƒë·∫ßu m·ªói t·ª´ (b·ªè s·ªë v√† b·ªè t·ª´ trong ngo·∫∑c)
  const words = clean.split(/\s+/).filter(w => w && !/^\d/.test(w) && !w.startsWith("("));
  let prefix = words.map(w => w[0]).join("");

  // 2. T√¨m c·ª•m s·ªë + ƒë∆°n v·ªã (330ML, 500G, 24LON...)
  let numberPart = "";
  const matchNumUnit = clean.match(/(\d+[A-Z]+)/);
  if (matchNumUnit) {
    numberPart = matchNumUnit[1];
  }

  // 3. N·∫øu c√≥ ngo·∫∑c ‚Üí l·∫•y ch·ªØ c√°i ƒë·∫ßu ti√™n trong ngo·∫∑c
  let bracketPart = "";
  const matchBracket = clean.match(/\(([^)]+)\)/);
  if (matchBracket) {
    const inner = matchBracket[1].trim();
    if (inner) bracketPart = "_" + inner[0];
  }

  return prefix + numberPart + bracketPart;
}


// ======================= T·∫†O M√É KH =======================
function generateCustomerCode(name) {
  if (!name) return "KH_XXX";
  const clean = removeVietnameseAccents(name.toUpperCase().trim());
  const words = clean.split(/\s+/).filter(Boolean);

  let code = words.map(w => w[0]).join("").substring(0, 5);
  return "KH_" + code.padEnd(5, "X");
}

// ======================= T·∫†O ROW =======================
function buildRow(flatMap) {
  const row = {};
  for (const col of ALL_COLS) {
    if (XML_MAPPING[col]) {
      row[col] = flatMap[XML_MAPPING[col]] || "";
    } else {
      row[col] = "";
    }
  }

  // ‚úÖ T√≠nh "ƒê∆°n gi√° sau thu·∫ø"
  const donGia = parseFloat(row["ƒê∆°n gi√°"] || 0);
  const thue = parseFloat((row["% thu·∫ø GTGT"] || "").replace("%","") || 0);
  row["ƒê∆°n gi√° sau thu·∫ø"] = donGia + (donGia * thue / 100);

  // ‚úÖ G√°n m·∫∑c ƒë·ªãnh
  row["TK Kho"] = "156";
  row["TK gi√° v·ªën"] = "632";
  row["TK thu·∫ø GTGT"] = "33311";

  // ‚úÖ M√£ kh√°ch h√†ng
  row["M√£ kh√°ch h√†ng"] = generateCustomerCode(row["T√™n kh√°ch h√†ng"]);

  // ‚úÖ M√£ h√†ng: n·∫øu tr·ªëng th√¨ sinh m·ªõi
  if (!row["M√£ h√†ng (*)"]) {
    row["M√£ h√†ng (*)"] = generateProductCodeByName(row["T√™n h√†ng"]);
  }

  return row;
}



// ======================= FORMAT DATE =======================
function formatDate(val) {
  if (!val) return "";
  // Nh·∫≠n d·∫°ng yyyy-mm-dd ho·∫∑c yyyy/mm/dd
  const match = val.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
  if (match) {
    const [, y, m, d] = match;
    return `${d}/${m}/${y}`;
  }
  // N·∫øu ƒë√£ ƒë√∫ng d·∫°ng dd/mm/yyyy th√¨ gi·ªØ nguy√™n
  const match2 = val.match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
  if (match2) return val;
  return val;
}

// ======================= RENDER B·∫¢NG =======================
function renderXmlTable() {
  const mainContent = document.getElementById("mainContent");
  if (!mainContent) return;

  // Thi·∫øt l·∫≠p CSS cho container ch√≠nh
  Object.assign(mainContent.style, {
    display: "flex",
    flexDirection: "column",
    height: "calc(100vh - 120px)",
    overflow: "hidden",
    fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
  });

  let html = `
    <style>
      #xmlTableContainer {
        flex: 1;
        overflow: auto;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background: white;
      }
      #xmlTable {
        border-collapse: collapse;
        min-width: 1200px;
        width: 100%;
        font-size: 13px;
      }
      #xmlTable thead th {
        border: 1px solid #d0d0d0;
        background: #f0f5ff;
        position: sticky;
        top: 0;
        z-index: 2;
        font-weight: 600;
        white-space: nowrap;
        padding: 10px 8px;
        color: #2c3e50;
        font-size: 14px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      }
      #xmlTable tbody td {
        border: 1px solid #e8e8e8;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
        padding: 6px 8px;
        height: 28px;
        max-height: 28px;
        line-height: 1.3;
      }
      #xmlTable tbody tr {
        transition: background-color 0.15s;
      }
      #xmlTable tbody tr:hover {
        background-color: #f8f9fa;
      }
      #xmlTable tbody tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      #xmlTable tbody tr:nth-child(even):hover {
        background-color: #f0f4f8;
      }
      .table-header {
        margin: 10px 0 12px 0;
        font-size: 18px;
        font-weight: 600;
        color: #2c3e50;
        padding-bottom: 8px;
        border-bottom: 2px solid #eaeaea;
      }
    </style>
    <div class="table-header">üìÑ B·∫£ng t·ªïng h·ª£p XML (1 file = 1 d√≤ng)</div>
    <div id="xmlTableContainer">
      <table id="xmlTable">
        <thead><tr>
          ${ALL_COLS.map(c => `<th>${c}</th>`).join("")}
        </tr></thead>
        <tbody>
  `;

  xmlRows.forEach((row, rIdx) => {
    html += "<tr>";
    ALL_COLS.forEach((col) => {
      let val = row[col] || "";

      // N·∫øu c·ªôt l√† ng√†y th√¨ format l·∫°i
      if (["Ng√†y h·∫°ch to√°n (*)", "Ng√†y ch·ª©ng t·ª´ (*)", "Ng√†y h√≥a ƒë∆°n"].includes(col)) {
        val = formatDate(val);
      }

      html += `
        <td 
          contenteditable="true" 
          data-row="${rIdx}" 
          data-col="${col}">${val}</td>`;
    });
    html += "</tr>";
  });

  html += "</tbody></table></div>";
  mainContent.innerHTML = html;

  // ‚úÖ B·∫Øt s·ª± ki·ªán ch·ªânh s·ª≠a √¥
  document.querySelectorAll("#xmlTable td[contenteditable]").forEach(td => {
    td.addEventListener("blur", e => {
      const rowIndex = parseInt(td.getAttribute("data-row"));
      const colName = td.getAttribute("data-col");
      let newValue = td.innerText.trim();

      // N·∫øu l√† c·ªôt ng√†y th√¨ chu·∫©n h√≥a v·ªÅ dd/MM/yyyy
      if (["Ng√†y h·∫°ch to√°n (*)", "Ng√†y ch·ª©ng t·ª´ (*)", "Ng√†y h√≥a ƒë∆°n"].includes(colName)) {
        newValue = formatDate(newValue);
        td.innerText = newValue; // update l·∫°i hi·ªÉn th·ªã
      }

      // c·∫≠p nh·∫≠t d·ªØ li·ªáu
      xmlRows[rowIndex][colName] = newValue;

      // l∆∞u l·∫°i
      saveXmlRows();
    });
  });
}



// ======================= HANDLE FILES =======================
async function handleFiles(filesInput) {
  const files = Array.isArray(filesInput) ? filesInput : Array.from(document.getElementById("zipFile").files);

  for (const file of files) {
    if (!file.name.toLowerCase().endsWith(".xml")) {
      window.showToast(`‚ö†Ô∏è B·ªè qua: ${file.name}`, 2000, "info");
      continue;
    }
    try {
      const xmlText = await file.text();
      const flatMap = flattenXml(xmlText);

      // ‚úÖ Kh√≥a duy nh·∫•t: ∆∞u ti√™n MCCQT, fallback sang SHDon
      const keyInvoice = flatMap["HDon.MCCQT"] || flatMap["HDon.DLHDon.TTChung.SHDon"] || "";
      if (!keyInvoice) {
        window.showToast(`‚ùå Kh√¥ng t√¨m th·∫•y MCCQT/S·ªë Hƒê trong ${file.name}`, 2000, "error");
        continue;
      }
      if (seenInvoiceKeys.has(keyInvoice)) {
        window.showToast(`‚ö†Ô∏è Tr√πng h√≥a ƒë∆°n: ${keyInvoice}`, 2000, "info");
        continue;
      }
      seenInvoiceKeys.add(keyInvoice);

      const row = buildRow(flatMap);
      xmlRows.push(row);
    } catch (err) {
      console.error("‚ùå L·ªói x·ª≠ l√Ω:", file.name, err);
      window.showToast(`‚ùå L·ªói file ${file.name}: ${err.message}`, 2000, "error");
    }
  }

  renderXmlTable();
  saveXmlRows();
}

// ======================= SAVE & LOAD =======================
function saveXmlRows() {
  window.localStorage.setItem("xmlRows", JSON.stringify(xmlRows));
  window.showToast("üíæ ƒê√£ l∆∞u d·ªØ li·ªáu", 1500, "success");
}

function loadXmlRows() {
  const saved = window.localStorage.getItem("xmlRows");
  if (saved) {
    try {
      const data = JSON.parse(saved);
      if (Array.isArray(data)) {
        xmlRows.length = 0;
        xmlRows.push(...data);
        renderXmlTable();
        window.showToast("üìÇ ƒê√£ t·∫£i d·ªØ li·ªáu ƒë√£ l∆∞u", 1500, "info");
      }
    } catch (e) {
      console.error("‚ùå L·ªói khi ƒë·ªçc localStorage:", e);
    }
  }
}

// ======================= INIT =======================
document.addEventListener("DOMContentLoaded", () => {
  loadXmlRows();
});
function clearXmlRows() {
  if (!confirm("‚ùì B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô d·ªØ li·ªáu ƒë√£ l∆∞u?")) return;
  xmlRows.length = 0;
  seenInvoiceKeys.clear();
  window.localStorage.removeItem("xmlRows");
  renderXmlTable();
  window.showToast("üóëÔ∏è ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu", 2000, "success");
}


/////
// ===== Helper lo·∫°i d·∫•u ti·∫øng Vi·ªát =====
function stripVN(s = "") {
  return s
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/ƒë/g, "d").replace(/ƒê/g, "D");
}

// ===== T·∫°o M√£ kh√°ch h√†ng: KH_ + 5 k√Ω t·ª± (∆∞u ti√™n ch·ªØ c√°i ƒë·∫ßu m·ªói t·ª´, c√≥ th·ªÉ l·∫•y s·ªë), thi·∫øu th√¨ pad 'X' =====
function buildCustomerCode(name = "") {
  const s = stripVN(name).trim();
  if (!s) return "KH_XXXXX";

  const tokens = s.split(/\s+/);
  let acc = "";

  for (const tRaw of tokens) {
    const t = tRaw.replace(/[^A-Za-z0-9]/g, "");
    if (!t) continue;
    // ∆∞u ti√™n k√Ω t·ª± ƒë·∫ßu c·ªßa token
    acc += t[0].toUpperCase();
    if (acc.length >= 5) break;
  }

  // N·∫øu v·∫´n thi·∫øu, th·ª≠ ‚Äúm∆∞·ª£n‚Äù ch·ªØ/s·ªë ti·∫øp theo trong t·ª´ng token
  if (acc.length < 5) {
    for (const tRaw of tokens) {
      const t = tRaw.replace(/[^A-Za-z0-9]/g, "");
      for (let i = 1; i < t.length && acc.length < 5; i++) {
        acc += t[i].toUpperCase();
      }
      if (acc.length >= 5) break;
    }
  }

  // N·∫øu c√≤n thi·∫øu n·ªØa, pad 'X'
  if (acc.length < 5) acc = (acc + "XXXXX").slice(0, 5);

  return `KH_${acc}`;
}

// ===== T·∫°o M√£ h√†ng: 3 ch·ªØ c√°i (t·ª´ t·ª´ d√†i nh·∫•t, l·∫•y 3 k√Ω t·ª± cu·ªëi) + s·ªë trong t√™n (n·∫øu c√≥). V√≠ d·ª• "Heineken 250" -> "ken250" =====
function buildProductCode(productName = "") {
  const s = stripVN(productName).toLowerCase();
  if (!s) return "mhxxx";

  const words = (s.match(/[a-z]+/g) || []);
  const digits = (s.match(/\d+/) || [""])[0]; // l·∫•y c·ª•m s·ªë ƒë·∫ßu ti√™n n·∫øu c√≥

  let alpha = "";
  if (words.length) {
    // l·∫•y t·ª´ c√≥ ƒë·ªô d√†i l·ªõn nh·∫•t
    let longest = words.reduce((a, b) => (b.length > a.length ? b : a), "");
    if (longest.length >= 3) alpha = longest.slice(-3);
    else {
      // n·∫øu t·ª´ d√†i nh·∫•t < 3, gh√©p c√°c t·ª´ ƒë·∫øn >=3
      const join = words.join("");
      alpha = (join + "xxx").slice(0, 3);
    }
  } else {
    alpha = "mhx"; // kh√¥ng c√≥ ch·ªØ c√°i n√†o
  }

  return `${alpha}${digits}`;
}
